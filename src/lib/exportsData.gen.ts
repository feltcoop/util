import type {Gen} from '@feltcoop/gro';
import {toImportId, toRootPath} from '@feltcoop/gro/dist/paths.js';
import {resolve} from 'path';

import {exports} from '$lib/exports';

interface ModuleInfo {
	path: string;
	mod: Record<string, any>;
	// TODO raw but probably use the AST: raw: Record<string, string>;
	identifiers: string[];
}

// Outputs exports data. Should use an existing library or at least the AST but this is interesting for now.
export const gen: Gen = async ({originId, fs}) => {
	const exps: Array<{path: string; importId: string}> = (
		await Promise.all(
			exports
				.map((path) => ({path, importId: toImportId(resolve('src/' + path), true, 'system')}))
				.map(async (d) => {
					if (await fs.exists(d.importId)) {
						return d;
					} else {
						return null!;
					}
				}),
		)
	).filter(Boolean);
	const mods: ModuleInfo[] = (await Promise.all(exps.map((exp) => import(exp.importId)))).map(
		(mod, i) => {
			const keys: string[] = Object.keys(mod);
			return {
				path: exps[i].path,
				mod,
				// TODO raw but probably use the AST: raw: keys.reduce((acc, key) => {
				// 	acc[key] = print(mod[key]);
				// 	console.log(`key`, key);
				// 	return acc;
				// }, {} as ModuleInfo['raw']),
				identifiers: keys,
			};
		},
	);

	return `
// generated by ${toRootPath(originId)}

export interface ExportsData {
	path: string;
	identifiers: string[];
}

export const exportsData: ExportsData[] = [
	${mods.map(
		(mod) =>
			// TODO raw but probably use the AST: raw: {${Object.entries(mod.raw).map(([k, v]) => `${k}: \`${v}\`,`)}}
			`{path: '${mod.path}', identifiers: [${mod.identifiers.map((m) => `'${m}'`).join(', ')}]}`,
		'',
	)}
];

// generated by ${toRootPath(originId)}
`.trim();
};
